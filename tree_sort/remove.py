import math
from collections import deque

import numpy as np
from scipy.special import rel_entr

# a = [
#     [41.84889, 27.76781, 93.96150, 47.37516, 114.45943, 64.92172, 63.04561, 121.05165],
#     [105.47352, 51.90095, 77.99996, 75.19883, 58.26318, 100.36079, 100.40953, 64.53143],
#     [96.25061, 15.90464, 49.97093, 63.08016, 86.43805, 94.10438, 42.91387, 119.24042],
#     [41.56463, 54.20832, 85.08684, -19.38369, 98.08325, 140.68963, 95.16351, 41.89139],
#     [91.85035, 87.15760, 82.48128, 65.04272, 72.29695, 97.74835, 40.60526, 77.64388],
#     [84.08710, 62.94007, 42.10331, 0.91035, 112.47165, 28.94859, 63.63791, 45.05598],
#     [55.90744, 54.27139, 67.13983, 34.16563, 59.47258, -4.62184, 63.04034, 95.58385],
#     [68.19048, 101.37411, 43.90105, 54.90471, 52.12978, 44.10185, 117.61041, 73.94832],
#     [93.03882, 35.27753, 33.81545, 91.09685, -5.44990, 50.53857, 102.26303, 69.10856],
#     [111.42916, 109.18014, 52.73678, 47.81179, 32.24657, 112.81179, 21.82656, 27.61429],
#     [100.93132, 68.59480, 54.28045, 73.56922, -5.19692, 119.83320, 48.92471, 70.36673],
#     [67.50117, 90.67522, 129.61142, 62.79154, 126.68087, 54.59694, 87.35002, 68.70735],
#     [99.41108, 67.97432, 51.52742, 95.31046, 84.24749, 56.60853, 35.16513, 25.19537],
#     [60.51053, 148.22558, 84.61786, 42.01974, 97.31839, 73.22125, 41.58546, 104.49555],
#     [55.67354, 42.73884, 105.84896, 92.34985, 61.85212, 74.25349, -11.88351, 48.10596],
#     [117.81353, 62.05750, -1.63840, 111.63285, 91.35278, 59.70119, 70.48220, 76.07412],
# ]
#
# b = [
#     [41.90924, 27.79083, 94.21127, 47.62280, 115.03003, 65.02062, 62.93753, 120.95852],
#     [105.52034, 52.25128, 78.43159, 75.53237, 58.53189, 100.76730, 100.74558, 64.62089],
#     [96.39924, 15.92188, 50.21037, 63.36192, 86.86648, 94.42482, 43.10008, 119.69896],
#     [41.64433, 54.34018, 85.21769, -19.38320, 98.13996, 140.71032, 95.25981, 41.94093],
#     [91.92346, 87.32565, 82.52427, 64.97744, 72.12531, 97.66150, 40.53883, 77.50436],
#     [83.73437, 62.78419, 41.99961, 0.93542, 112.07370, 28.83398, 63.45359, 45.05750],
#     [55.95323, 54.25810, 67.08469, 34.14083, 59.53485, -4.61691, 62.87938, 95.23323],
#     [68.05766, 101.28573, 43.94128, 54.93242, 52.06387, 44.02097, 117.30235, 73.82208],
#     [92.81357, 35.19373, 33.71446, 90.88513, -5.44216, 50.43640, 101.98800, 68.88400],
#     [111.14944, 108.95717, 52.69243, 47.79183, 32.24724, 113.03096, 21.83527, 27.68782],
#     [101.03807, 68.57562, 54.23037, 73.53848, -5.19872, 119.60704, 48.93919, 70.59204],
#     [67.74942, 90.82681, 129.50054, 62.94621, 127.01037, 54.73774, 87.16390, 68.45706],
#     [99.08973, 67.81814, 51.51849, 95.34536, 84.39830, 56.81609, 35.26354, 25.30225],
#     [60.54658, 148.20854, 84.60662, 42.00063, 97.26682, 73.14096, 41.59700, 104.50968],
#     [55.66670, 42.75043, 105.95481, 92.30111, 61.68411, 73.90937, -11.84089, 47.95267],
#     [117.51129, 61.85574, -1.62591, 111.25857, 91.00361, 59.48569, 70.25017, 75.79869],
# ]
#
# e = [
#     [38.38518, 25.74613, 87.18328, 44.67514, 107.68313, 61.14095, 60.46736, 117.86923],
#     [103.58021, 51.35494, 77.15206, 74.51011, 56.27738, 94.40971, 92.00881, 57.61619],
#     [86.82143, 14.53839, 46.93997, 58.22437, 80.14432, 85.01790, 39.60175, 110.47762],
#     [39.58868, 52.33434, 82.84289, -18.85166, 96.46822, 136.50557, 90.39156, 39.55046],
#     [85.53208, 80.96093, 76.31756, 61.14445, 69.32536, 96.66305, 40.79212, 78.02314],
#     [83.40464, 60.52142, 39.71821, 0.77263, 108.57108, 28.31771, 61.01711, 42.38484],
#     [52.86214, 52.03819, 64.87666, 32.97426, 56.53300, -4.45452, 58.56532, 88.28662],
#     [63.18361, 93.71917, 40.22297, 50.02596, 48.14936, 41.36059, 109.53514, 68.94373],
#     [86.48573, 33.17306, 32.17934, 86.10467, -4.97471, 46.63264, 94.58190, 64.06340],
#     [105.36687, 102.56917, 49.55033, 44.36535, 30.00261, 104.74118, 20.11412, 25.32642],
#     [92.57965, 62.91581, 50.18340, 68.15881, -4.73595, 112.22953, 46.62470, 67.98276],
#     [64.93716, 85.55120, 121.81145, 59.22058, 120.15290, 53.13185, 87.62908, 69.07996],
#     [98.92653, 66.25648, 50.99628, 96.21006, 86.25166, 58.14706, 35.06812, 24.27845],
#     [57.94504, 144.56176, 84.83032, 42.87226, 99.01586, 74.45338, 41.86639, 106.05773],
#     [56.29365, 43.18324, 107.27487, 93.17119, 62.12250, 73.93175, -11.74382, 47.66894],
#     [117.09316, 62.72205, -1.60130, 112.87662, 91.23529, 59.58531, 70.38882, 75.76757],
# ]

a = [0.02125, -0.05875, -0.39208, -0.57875, -0.67208, -0.59208, -0.36542, -0.51208, -0.85875, -0.85875, -0.72542,
     -0.47208, 0.02125, -0.28542, -0.73875, -0.59208, -0.59208, -0.17875, -0.16542, -0.65875, -0.76542, -0.75208,
     -0.65875, -0.20542, -0.04542, -0.52542, -0.85875, -0.85875, -0.76542, -0.55208, -0.33875, -0.64542, -0.79208,
     -0.84542, -0.65875, -0.17875, 0.30125, 0.12792, -0.16542, -0.31208, 0.55458, 1.02125, 0.80792, 0.35458, 0.51458,
     0.03458, 0.66125, 1.10125, 0.94125, 0.90125, 0.59458, 0.54125, 0.92792, 1.14125, 1.14125, 1.08792, 0.75458,
     0.87458, 1.04792, 1.11458, 0.90125, 0.56792, 0.31458, 0.84792
     ]

b = [-0.11479, -0.19479, -0.39479, -0.51479, -0.52813, -0.52813, -0.48813, -0.55479, -0.54146, -0.52813, -0.44813,
     -0.40813, -0.46146, -0.59479, -0.47479, -0.39479, -0.51479, -0.52813, -0.47479, -0.58146, -0.52813, -0.52813,
     -0.47479, -0.30146, -0.40813, -0.52813, -0.52813, -0.52813, -0.43479, -0.22146, -0.00812, -0.44813, -0.52813,
     -0.52813, -0.52813, -0.28813, -0.00813, -0.31479, -0.36813, -0.35479, 0.20521, 0.65854, 0.76521, 0.23188, 0.33854,
     0.05854, 0.32521, 1.09854, 0.75187, 0.53854, 0.51187, 0.51187, 1.23188, 1.43187, 1.07188, 0.93854, 0.87188,
     1.07187, 1.11188, 1.32521, 0.89854, 0.28521, 0.13854, 0.75188
     ]

e = [-126.67280, -125.29131, -123.31871, -123.76695, -126.33566, -124.97063, -124.32450, -125.07177, -126.13432,
     -124.51391, -125.44937, -125.95408, -125.87996, -125.44801, -126.90099, -126.16081, -125.12704, -125.92129,
     -125.96767, -124.94832, -125.19246, -124.39313, -125.15416, -124.90052, -126.85816, -126.37520, -126.02728,
     -124.98390, -126.07116, -126.91094, -124.44067, -125.56603, -125.34121, -125.36188, -124.57253, -125.80737,
     -127.26487, -125.83691, -126.29050, -125.44770, -125.03252, -124.72176, -125.15460, -125.60627, -124.66682,
     -123.32550, -124.47495, -125.61150, -124.49619, -123.70164, -124.89417, -126.65704, -125.48061, -124.79160,
     -125.69474, -127.78718, -128.50826, -127.26950, -126.96548, -126.35105, -125.69900, -125.77702, -124.76802,
     -125.60414
     ]

n = [-95.99458, 586.64789, 511.46049, 292.96866, -63.42612, -449.27752, -181.69349, -419.13316, -544.86325, 267.52003,
     -341.49926, 89.37122, 307.48100, 461.15821, 74.26181, -65.20134, -467.00823, -532.50657, -419.45643, -34.37739,
     -243.51251, -1147.51758, -191.25060, -550.49771, -818.65083, -240.84108, 277.08963, 351.96556, -26.89028,
     203.78166, 98.89409, -666.35619, -270.93117, 482.15713, -100.97892, -181.42471, 335.63305, 50.45194, -85.12705,
     -76.38228, -197.85236, 66.70418, 980.83293, 126.65714, -557.27252, -448.70268, -254.04879, -810.20555, -1173.48670,
     -460.37277, 361.85079, -267.81640, -653.00607, 51.41774, -478.47763, 271.13518, 495.65672, -58.05631, -988.61802,
     -786.81995, -156.17952, -52.47604, 167.07343, -55.01314
     ]


# list 待排序的数组
# length 比较中所需的最小比较单元的长度
def binaryTreeSort(data, length, noise):
    extend_list = data.copy()
    for i in range(2 ** math.ceil(np.log2(len(data))) - len(data)):
        extend_list.append(0)

    for i in range(2 ** math.ceil(np.log2(len(noise))) - len(noise)):
        noise.append(0)

    q = deque()
    q.append([1, len(extend_list)])
    index = []
    linear_code = []
    while q:
        l = q.popleft()
        index.append(l)
        if l[1] != l[0]:
            q.append([l[0], math.floor((l[0] + l[1]) / 2)])
            q.append([math.ceil((l[0] + l[1]) / 2), l[1]])

    # 用等比数列求和公式算出index总共有几层，注意公比为2
    max_level = int(np.log2(len(index) + 1))
    intervals = []
    cur_interval = 0
    for i in range(max_level):
        intervals.append(index[cur_interval][1] - index[cur_interval][0] + 1)
        cur_interval = cur_interval + 2 ** i
    intervals.append(0)
    linear_code.append("0")
    code = [["0"]]

    metrics = []
    cur = 1
    for i in range(1, max_level):
        tmpMetrics = []
        for j in range(cur, cur + 2 ** i, 2):
            l1l = index[j][0] - 1
            l1r = index[j][1]
            l2l = index[j + 1][0] - 1
            l2r = index[j + 1][1]
            # if l1r - l1l < length:
            #     break
            # tmpMetrics.append(ddtw(extend_list[l1l: l1r], extend_list[l2l: l2r], dist=derivative_metric)[0])
            # tmpMetrics.append(sum(rel_entr(extend_list[l1l: l1r], extend_list[l2l: l2r])))
            tmpMetrics.append([sum(extend_list[l1l: l1r]), sum(extend_list[l2l: l2r])])
        metrics.append(tmpMetrics)
        cur = cur + 2 ** i

    cur = 1
    for i in range(1, max_level):
        cur_code = []
        for j in range(cur, cur + 2 ** i, 2):
            tmp1 = linear_code[int(j / 2)]
            tmp2 = linear_code[int(j / 2)]
            l1l = index[j][0] - 1
            l1r = index[j][1]
            l2l = index[j + 1][0] - 1
            l2r = index[j + 1][1]
            # if l1r - l1l < length:
            #     break
            # metric1 = sum(rel_entr(extend_list[l1l: l1r], noise[l1l: l1r]))
            # metric2 = sum(rel_entr(extend_list[l2l: l2r], noise[l2l: l2r]))
            step = int((l1r - l1l) / 2)
            metric1 = sum(rel_entr(extend_list[l1l: l1r], noise[l1l: l1r]))
            metric2 = sum(rel_entr(extend_list[l2l: l2r], noise[l2l: l2r]))
            # metric1 = dtw(extend_list[l1l: l1r], noise[l1l: l1r], dist=manhattan_distance)[0]
            # metric2 = dtw(extend_list[l2l: l2r], noise[l2l: l2r], dist=manhattan_distance)[0]
            # metric = pearsonr(extend_list[l1l: l1r], extend_list[l2l: l2r])[0]
            # metric = ddtw(extend_list[l1l: l1r], extend_list[l2l: l2r], dist=derivative_metric)[0]
            metric = sum(rel_entr(extend_list[l1l: l1r], extend_list[l2l: l2r]))
            # if i >= len(metrics):
            #     break
            if metric1 >= metric2:
                tmp1 += "0"
                tmp2 += "1"
            else:
                tmp1 += "1"
                tmp2 += "0"
            # 记录当前code，用于子节点使用
            linear_code.append(tmp1)
            linear_code.append(tmp2)
            # 记录当前code，用于输出
            cur_code.append(tmp1)
            cur_code.append(tmp2)
        cur = cur + 2 ** i
        code.append(cur_code)

    return_code = []
    for i in range(1, len(intervals)):
        if intervals[i] < length:
            return_code = code[i - 1]
            break

    for i in range(len(return_code)):
        return_code[i] = return_code[i][1:]
    return return_code


def asymmetricKL(P, Q):
    l = np.log(P / Q)
    return sum(P * l)


def symmetricalKL(P, Q):
    return (asymmetricKL(P, Q) + asymmetricKL(Q, P)) / 2.00


# manhattan_distance = lambda x, y: np.abs(x - y)
a = a - np.min(a) + 0.1
b = b - np.min(b) + 0.1
e = e - np.min(e) + 0.1
n = n - np.min(n) + 0.1

# a = a - np.mean(a)
# b = b - np.mean(b)
# e = e - np.mean(e)
# n = n - np.mean(n)

# plt.figure()
# plt.plot(a, "r")
# plt.plot(b, "b")
# plt.plot(e, "k")
# plt.show()

# print(sum(rel_entr(a[0:64], b[0:64])))
# print(sum(rel_entr(a[0:64], e[0:64])))
# print(sum(rel_entr(a[0:64], n[0:64])))
# print()

# print(sum(rel_entr(a[0:32], a[32:64])))
# print(sum(rel_entr(b[0:32], b[32:64])))
# print(sum(rel_entr(e[0:32], e[32:64])))
# print(sum(rel_entr(n[0:32], n[32:64])))
# print()

# print(dtw(a[0:64], b[0:64], dist=manhattan_distance)[0])
# print(dtw(a[0:64], e[0:64], dist=manhattan_distance)[0])
# print(dtw(a[0:64], n[0:64], dist=manhattan_distance)[0])
# print()
#
# print(ddtw(a[0:64], b[0:64], dist=derivative_metric)[0])
# print(ddtw(a[0:64], e[0:64], dist=derivative_metric)[0])
# print(ddtw(a[0:64], n[0:64], dist=derivative_metric)[0])
# print()

# print(dtw(a[0:32], a[32:64], dist=manhattan_distance)[0])
# print(dtw(b[0:32], b[32:64], dist=manhattan_distance)[0])
# print(dtw(e[0:32], e[32:64], dist=manhattan_distance)[0])
# print(dtw(n[0:32], n[32:64], dist=manhattan_distance)[0])
# print()
#
# print(ddtw(a[0:32], a[32:64], dist=derivative_metric)[0])
# print(ddtw(b[0:32], b[32:64], dist=derivative_metric)[0])
# print(ddtw(e[0:32], e[32:64], dist=derivative_metric)[0])
# print(ddtw(n[0:32], n[32:64], dist=derivative_metric)[0])
# print()
#
# print(dtw(a[0:16], a[16:32], dist=manhattan_distance)[0])
# print(dtw(b[0:16], b[16:32], dist=manhattan_distance)[0])
# print(dtw(e[0:16], e[16:32], dist=manhattan_distance)[0])
# print(dtw(n[0:16], n[16:32], dist=manhattan_distance)[0])
# print()
#
# print(ddtw(a[0:16], a[16:32], dist=derivative_metric)[0])
# print(ddtw(b[0:16], b[16:32], dist=derivative_metric)[0])
# print(ddtw(e[0:16], e[16:32], dist=derivative_metric)[0])
# print(ddtw(n[0:16], n[16:32], dist=derivative_metric)[0])


# for i in range(1, int(len(a) / 4)):
#     print((np.sum(a[i:i+4]) - np.sum(a[i - 1:i+3]))/ 2)
#     print((np.sum(b[i:i+4]) - np.sum(b[i - 1:i+3]))/ 2)
#     print((np.sum(e[i:i+4]) - np.sum(e[i - 1:i+3]))/ 2)
#     print()

a_list_number = binaryTreeSort(a, 16, n)
b_list_number = binaryTreeSort(b, 16, n)
e_list_number = binaryTreeSort(e, 16, n)
n_list_number = binaryTreeSort(n, 16, n)

a_list = []
b_list = []
e_list = []
n_list = []

for i in range(len(a_list_number)):
    a_list.append(int(a_list_number[i], 2))
for i in range(len(b_list_number)):
    b_list.append(int(b_list_number[i], 2))
for i in range(len(e_list_number)):
    e_list.append(int(e_list_number[i], 2))
for i in range(len(n_list_number)):
    n_list.append(int(n_list_number[i], 2))

print(a_list)
print(b_list)
print(e_list)
print(n_list)

sum1 = min(len(a_list), len(b_list))
sum2 = 0
sum3 = 0
sum4 = 0
for i in range(0, sum1):
    sum2 += (a_list[i] == b_list[i])
for i in range(min(len(a_list), len(e_list))):
    sum3 += (a_list[i] == e_list[i])
for i in range(min(len(a_list), len(n_list))):
    sum4 += (a_list[i] == n_list[i])

if sum2 == sum1:
    print("\033[0;32;40ma-b", sum2, sum2 / sum1, "\033[0m")
else:
    print("\033[0;31;40ma-b", sum2, sum2 / sum1, "\033[0m")
print("a-e", sum3, sum3 / sum1)
print("a-n", sum4, sum4 / sum1)
