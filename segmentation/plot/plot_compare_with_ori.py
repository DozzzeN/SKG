import matplotlib.pyplot as plt
import numpy as np

# 横坐标：分段个数，从4到256
segments = ["4 * 4", "4 * 8", "4 * 16", "4 * 32", "4 * 64"]
# segments = ["4 * 4", "4 * 8", "4 * 16", "4 * 32", "4 * 64", "4 * 128", "4 * 256"]

# 纵坐标：比特匹配率 (未知)
fixed_segment_matching_rates = [
    0.972325103, 0.978514552, 0.977929043, 0.98236755, 0.987916667, 0.992489141, 0.989420573
]

# test_sorting_sorting_addnoise_dtw_test_sorting_ori.py (无随机矩阵优化，只用index，未根据值过滤，格雷码编码，欧式距离)
fixed_segment_matching_rates2 = [
    0.972736626, 0.978583196, 0.979579208, 0.983443709, 0.986875, 0.992157336, 0.989095052
]

# test_sorting_sorting_addnoise_dtw_test_sorting_ori.py (无随机矩阵优化，只用index，未根据值过滤，格雷码编码，dtw距离)
# 首选
# fixed_segment_matching_rates3 = [
#     0.967078189, 0.976661175, 0.976794554, 0.980504967, 0.984409722, 0.990679295, 0.987331814
# ]
fixed_segment_matching_rates3 = [
    0.967078189, 0.976661175, 0.976794554, 0.980504967, 0.984409722
]

# test_sorting_sorting_addnoise_dtw_test_sorting_ori.py (无随机矩阵优化，只用index，未根据值过滤，格雷码编码，曼哈顿距离)
fixed_segment_matching_rates4 = [
    0.971193416, 0.979063701, 0.979063531, 0.983236755, 0.987604167, 0.991916023, 0.989149306
]

# test_sorting_sorting_addnoise_dtw_test_sorting_ori.py (无随机矩阵优化，只用index，根据值过滤，格雷码编码，欧式距离)
fixed_segment_matching_rates5 = [
    0.97312603, 0.978583196, 0.979579208, 0.983443709, 0.986875, 0.992157336, 0.989095052
]

# test_sorting_sorting_addnoise_dtw_test_sorting_ori.py (无随机矩阵优化，只用index，cox-box，根据值过滤，格雷码编码，欧式距离)
fixed_segment_matching_rates6 = [
    0.981687243, 0.985104338, 0.989892739, 0.989900662, 0.994895833, 0.993816361, 0.995279948
]


#####################################################
# (不设置阈值的) (无随机矩阵优化，不根据值过滤，无格雷码编码)
adaptive_segment_matching_rates = [
    0.996506986, 0.993461353, 0.995854107, 0.996230357, 0.993700279, 0.996930589, 0.99440696
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，格雷码编码)
adaptive_segment_matching_rates2 = [
    0.996257198, 0.993382589, 0.994848778, 0.992715376
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，格雷码编码，无cox-box)
adaptive_segment_matching_rates3 = [
    0.995197849, 0.988387097, 0.989058186, 0.993228615
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，无格雷码编码，无cox-box)
adaptive_segment_matching_rates4 = [
    0.995505394, 0.986343955, 0.988911398, 0.992879331
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，无格雷码编码，cox-box) add额外公开数据
adaptive_segment_matching_rates5 = [
    0.999168537, 0.999213551, 0.998327759, 1.0, 1.0
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，无格雷码编码，cox-box) add额外公开数据
eve_adaptive_segment_matching_rates5 = [
    0.704498212, 0.644948578, 0.558900037, 0.521663527, 0.503442501
]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，无格雷码编码，cox-box) replace数据
adaptive_segment_matching_rates6 = [
    1.0, 0.997781721, 1.0, 1.0, 1.0

]

# (不设置阈值的) (无随机矩阵优化，根据值过滤，无格雷码编码，cox-box) replace数据
eve_adaptive_segment_matching_rates6 = [
    0.516185748, 0.49689441, 0.494740218, 0.49675415, 0.505455308

]

# (modify_segments_position_compared_with_one_segments)
# [0, 1]
# 0.998635278, 0.995976377, 0.995451329, 0.997180451
# [-1, 2]
# 0.999659922, 0.997933751, 0.997217726, 0.99684456
# [-1, 2] max_dist
# 0.999825251, 0.998376307, 0.998361579
# [-1, 2] max_dist 考虑add后的分段长度 设定min_length
# 0.999696002, 0.997945868
# 设定min_length=3
# 0.999695933, 0.998790883, 0.992571373, 0.993132511
# 固定是[2, -1] max_dist
# 1.0, 0.997177737, 0.994960806
# [-1, 2] max_dist 考虑add后的分段长度 设定min_length=3 add的长度为segNum
# 4 * 4  0.999695933 0.999176955 0.676697531 0.67649177  / 0.695933105 0.312757202
# 4 * 8  1.0         1.0         0.977570998 0.977570998 / 0.549821183 0.04302926
# 4 * 16 0.998661424 0.993377483 1.236858444 1.235202815 / 0.508993558 0.0
# 4 * 32 1.0         1.0         1.16796875  1.16796875  / 0.518394649 0.0

# [-1, 2] max_dist 考虑add后的分段长度 设定min_length=3 add的长度为segNum 不考虑分段导致内存溢出的限制
# (modify_segments_position_compared_with_one_segments)
# 4 * 4  0.999695933 0.999176955 0.676697531 0.67649177  / 0.695933105 0.312757202
# 4 * 8  1.0         1.0         0.977570998 0.977570998 / 0.549821183 0.04302926
# 4 * 16
# 4 * 32

# [-1, 2] max_dist 考虑add后的分段长度 设定min_length=3 add的长度为segNum 考虑分段位置与其他所有分段的距离
# (modify_segments_position_compared_with_all_segments)
# 4 * 4  1.0         1.0         0.665277778 0.665277778 / 0.714374082 0.357201646
# 4 * 8  1.0         1.0         0.977570998 0.977570998 / 0.549325997 0.034423408
# 4 * 16 1.0         1.0         1.223053496 1.223053496 / 0.509392086 0.0
# 4 * 32 1.0         1.0         1.094494048 1.094494048 / 0.495581237 0.0

# [-1, 2] max_dist 考虑add后的分段长度 设定min_length=3 add的长度为segNum 在分段后进行添加
# test_sorting_sorting_addnoise_dtw_test_sorting_insert_after_segment.py
# 4 * 4  0.997749821 0.995884774 0.502932099 0.501800412 / 0.504142375 0.041152263
# 4 * 8  0.993219129 0.981878089 0.721272652 0.716381796 / 0.504853676 0.0
# 4 * 16 0.995808574 0.983333333 0.981666667 0.977552083 / 0.498302207 0.0
# 4 * 32 0.993135954 0.979166667 1.185601128 1.177463108 / 0.502585457 0.0

# [-1, 2] max_dist 考虑add后的分段长度 设定min_length=3 add的长度为segNum 均匀添加
# (modify_segments_with_even_addition)
# 4 * 4   0.999168537 0.997530864 0.61867284  0.618158436 / 0.704498212 0.27654321
# 4 * 8   0.999213551 0.996705107 0.851009061 0.850339786 / 0.644948578 0.026359143
# 4 * 16  0.998327759 0.996587031 1.148037543 1.146117747 / 0.558900037 0.0
# 4 * 32  1.0         1.0         1.273560531 1.273560531 / 0.521663527 0.0
# 4 * 64  1.0         1.0         1.584316038 1.584316038 / 0.503442501 0.0
# 4 * 128 1.0         1.0         1.80131392  1.80131392  / 0.498570724 0.0

# 只添加一个分段(即4)
# 4 * 128 0.98747528 0.954545455 1.616122159 1.595880682 / 0.499395737 0.0


# 替换分段 count > 10 替换个数为segLen
# 4 * 4  0.993828946 0.985185185 0.533487654 0.530195473 / 0.504097965 0.038683128

# 替换分段 count > 3 替换个数为segLen
# 4 * 4  0.989071038 0.976131687 0.536574074 0.530709877 / 0.510593423 0.03127572

# 替换分段 count > 3 替换个数为segLen * 2
# 4 * 4  0.989071038 0.976131687 0.536574074 0.530709877 / 0.510593423 0.03127572

# 替换分段 count > 10 替换个数为segLen * 2
# 4 * 4  0.975392157 0.948971193 0.524691358 0.511779835 / 0.504313725 0.032098765
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 4 * 4  0.997133028 0.994238683 0.538271605 0.536728395 / 0.593654434 0.167901235
# 4 * 8  0.997061637 0.993366501 0.758395522 0.756167081 / 0.549132158 0.026533997
# 4 * 16 1.0         1.0         1.005190678 1.005190678 / 0.528612077 0.0
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen
# 4 * 4  0.99792492  0.995884774 0.54537037  0.544238683 / 0.615638559 0.192592593

# 不加噪音 替换矩阵也不加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 4
# 4 * 4  0.99769784 0.993415638 0.536265432 0.535030864  / 0.523741007 0.079835391
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 3
# 4 * 4  0.99750455 0.994238683 0.53595679  0.534619342  / 0.537479605 0.091358025
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 4 * 4  0.99769253 0.994238683 0.535030864 0.533796296  / 0.534083261 0.088888889
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen
# 4 * 4  0.996248196 0.99259259 0.534722222 0.532716049  / 0.531986532 0.09218107
# 4 * 4  0.996266513 0.99259259 0.537345679 0.535339506  / 0.531399579 0.070781893
# 修改replace method 不限定与原始数据的差距
# 4 * 4  0.99769253 0.994238683 0.535030864 0.533796296  / 0.534083261 0.088888889

# 测试1
# 不加噪音 替换矩阵也不加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 4 * 8  0.9973824  0.995041322 0.670919421 0.669163223  / 0.507429363 0.00661157
# 过滤
# 4 * 8  0.99741747 0.99513382  0.677159367 0.675410584  / 0.502807096 0.01216545
# 测试2
# 不加噪音 替换矩阵加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 4 * 8  0.99406257 0.99008264  0.67856405  0.674535124  / 0.499048489 0.001652893
# 过滤
# 4 * 8  0.99778172 0.995157385 0.68220339  0.680690073  / 0.496672582 0.002421308
# 测试3
# 不加噪音 替换矩阵也不加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 修改replace method 不限定与原始数据的差距
# 4 * 8  0.99626651 0.992592593 0.537345679 0.535339506  / 0.531399579 0.070781893
# 过滤
# 4 * 8  1.0        1.0         0.5395      0.5395       / 0.531253218 0.070222222
# 测试4
# 不加噪音 替换矩阵加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 修改replace method 不限定与原始数据的差距
# 4 * 8  0.996298461 0.993415638 0.52808642  0.52613168 / 0.51539061  0.057613169  run back ratio 54 / 1215 = 0.044444
# 过滤
# 4 * 8  1.0         1.0         0.529286649 0.52928664 / 0.516537867 0.055846422  run back ratio 44 / 1146 = 0.038394

# 不加噪音 替换矩阵加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2
# 修改replace method 不限定与原始数据的差距
# 4 * 4  0.996298461 0.993415638 0.52808642 0.526131687  / 0.51539061  0.057613169
# 不加噪音 替换矩阵加噪音
# 公开替换矩阵 替换分段 count > 10 替换个数为segLen * 2 (最初结果)
# 4 * 4  0.997554773 0.995061728 0.52592592 0.524639918  / 0.515160407 0.074074074

# 替换分段 count > 10 替换个数为segLen * 3
# 4 * 4  0.95749308  0.910288066 0.52037037  0.498251029 / 0.507216291 0.044444444

# 替换分段 count > 3同时min_new_dtw_distance < ori_dist_threshold 替换个数为segLen * 2
# 4 * 4  0.996322106 0.991769547 0.531481481 0.529526749 / 0.504452187 0.040329218

# 将匹配率转换为不匹配率
fixed_segment_non_matching_rates = [1 - rate for rate in fixed_segment_matching_rates3]
adaptive_segment_non_matching_rates = [1 - rate for rate in adaptive_segment_matching_rates6]
eve_adaptive_segment_non_matching_rates = [1 - rate for rate in eve_adaptive_segment_matching_rates6]

# 设置柱状图的位置
x = np.arange(len(segments))  # the label locations
width = 0.2  # the width of the bars

fig, ax = plt.subplots()
bars1 = ax.bar(x - width, fixed_segment_non_matching_rates, width, label='Fixed Segmentation')
bars2 = ax.bar(x, adaptive_segment_non_matching_rates, width, label='Adaptive Segmentation')
bars3 = ax.bar(x + width, eve_adaptive_segment_non_matching_rates, width, label='Eve Adaptive Segmentation')

# 添加一些文本用于标注
ax.set_xlabel('Number of Elements')
ax.set_ylabel('Bit Mismatch Rate')
ax.set_title('BMR by Number of Episodes and Segmentation Method')
ax.set_xticks(x)
ax.set_xticklabels(segments)
ax.legend()
ax.set_ylim([0, 0.7])

# 在柱状图上添加标签
# 在每个柱子上标出具体值
for bars in [bars1, bars2, bars3]:
    for bar in bars:
        height = bar.get_height()
        ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')

# for bar in bars1:
#     yval = bar.get_height()
#     plt.text(bar.get_x() + bar.get_width() / 2.0, yval, f'{yval:.3f}', ha='center',
#              va='bottom')  # ha: horizontal alignment
#
# for bar in bars2:
#     yval = bar.get_height()
#     plt.text(bar.get_x() + bar.get_width() / 2.0, yval, f'{yval:.3f}', ha='center',
#              va='bottom')  # ha: horizontal alignment

fig.tight_layout()

plt.savefig('compare.svg', dpi=1200, bbox_inches='tight')
plt.show()
